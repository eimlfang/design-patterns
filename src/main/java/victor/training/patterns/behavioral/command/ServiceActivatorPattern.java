// Generated by delombok at Wed Oct 14 12:32:37 EEST 2020
package victor.training.patterns.behavioral.command;

import org.apache.commons.lang.NotImplementedException;
import org.springframework.cloud.stream.messaging.Source;
import org.springframework.integration.annotation.MessageEndpoint;
import org.springframework.stereotype.Service;

@Service
public class ServiceActivatorPattern {
    @java.lang.SuppressWarnings("all")
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(ServiceActivatorPattern.class);
    private final Source source;

    public ServiceActivatorPattern(Source source) {
        this.source = source;
    }

    public void askInParallel() {
        log.info("Sending messages");
        //source.output().send(MessageBuilder.withPayload(...).build());
        log.info("Sent messages");
    }
}

enum DrinkType {
    BEER, VODKA;
}

@MessageEndpoint
class MessageHandler {
    @java.lang.SuppressWarnings("all")
    private static final org.slf4j.Logger log = org.slf4j.LoggerFactory.getLogger(MessageHandler.class);
    private final Barman barman;

    public MessageHandler(Barman barman) {
        this.barman = barman;
    }

    //@ServiceActivator(inputChannel = Sink.INPUT)
    // TODO check parallelism
    public void handleOrder(DrinkType drinkType) {
        log.info("Executing order for {} in handler {}", drinkType, this);
        Object drink = callBarman(drinkType);
        log.info("Got drink: " + drink);
    }

    private Object callBarman(DrinkType drinkType) {
        switch (drinkType) {
        case BEER: 
            return barman.pourBeer();
        case VODKA: 
            return barman.pourVodka();
        default: 
            throw new NotImplementedException("Unknown drink type: " + drinkType);
        }
    }
}
